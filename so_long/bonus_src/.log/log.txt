=== start of ./2_boot/boot.c ===

#include "bonus_boot_lib.h"

static void	find_exit(t_map *map)
{
	int		y;
	int		x;
	char	**arr;

	arr = map->layout;
	y = 1;
	while (arr[y])
	{
		x = 1;
		while (arr[y][x])
		{
			if (arr[y][x] == 'E')
			{
				map->e_x = x;
				map->e_y = y;
				return ;
			}
			x++;
		}
		y++;
	}
}

static void	count_coins(int *coins, char **map)
{
	int	y;
	int	x;

	y = 1;
	while (map[y])
	{
		x = 1;
		while (map[y][x])
		{
			if (map[y][x] == 'C')
				*coins += 1;
			x++;
		}
		y++;
	}
}

static void	boot_t_game(t_game *game)
{
	game->error_bitmask = 0;
	game->move_count = 0;
	game->map_render = 1;
	game->p_x = 0;
	game->p_y = 0;
	game->coins = 0;
	game->mlx = NULL;
	game->win = NULL;
	game->map = ft_calloc(1, sizeof(t_map));
	game->assets = ft_calloc(1, sizeof(t_assets));
	game->player = ft_calloc(1, sizeof(t_player));
	if (!game->map || !game->assets || !game->player)
		game->error_bitmask |= MALLOCS_ER;
}

void	ft_boot_game(t_game *game, char *file)
{
	boot_t_game(game);
	if (game->error_bitmask)
		return ;
	game->assets->map_file = file;
	ft_boot_map(game);
	if (game->error_bitmask)
		return ;
	count_coins(&game->coins, game->map->layout);
	find_exit(game->map);
	ft_boot_player(game);
}
=== end of ./2_boot/boot.c ===
=== start of ./2_boot/detail_map.c ===

#include "bonus_boot_lib.h"

int	ft_is_wall(t_map map, int y, int x)
{
	char	c;
	int		s_x;
	int		s_y;

	s_x = map.x;
	s_y = map.y;
	if (x < 0 || x >= s_x || y < 0 || y >= s_y)
		return (1);
	c = map.layout[y][x];
	return (c == '1');
}

static char latter_walls(int mask_dir, int mask_dig)
{
	if (mask_dir == 10)
		return ('Q');
	if (mask_dir == 11)
		return ("RSTU"[BITMASK_B[mask_dig] - '0']);
	if (mask_dir == 12)
		return ("VW"[BITMASK_C[mask_dig] - '0']);
	if (mask_dir == 13)
		return ("XYZ%"[BITMASK_D[mask_dig] - '0']);
	if (mask_dir == 14)
		return ("!@#$"[BITMASK_E[mask_dig] - '0']);
	if (mask_dir == 15)
		return (BITMASK_F[mask_dig]);
	return ('*');
}

static char	give_wall(int mask_dir, int mask_dig)
{
	if (mask_dir == 0)
		return ('A');
	if (mask_dir == 1)
		return ('B');
	if (mask_dir == 2)
		return ('C');
	if (mask_dir == 3)
		return ("DE"[BITMASK_3[mask_dig] - '0']);
	if (mask_dir == 4)
		return ('F');
	if (mask_dir == 5)
		return ('G');
	if (mask_dir == 6)
		return ("HI"[BITMASK_6[mask_dig] - '0']);
	if (mask_dir == 7)
		return ("JKLM"[BITMASK_7[mask_dig] - '0']);
	if (mask_dir == 8)
		return ('N');
	if (mask_dir == 9)
		return ("OP"[BITMASK_9[mask_dig] - '0']);
	return (latter_walls(mask_dir, mask_dig));
}

char	ft_prep_wall(t_map map, int y, int x)
{
	int	wasd_mask;
	int	diag_mask;

	wasd_mask = 0;
	wasd_mask |= ft_is_wall(map, y - 1, x + 0) << 3;
	wasd_mask |= ft_is_wall(map, y + 0, x - 1) << 2;
	wasd_mask |= ft_is_wall(map, y + 1, x + 0) << 1;
	wasd_mask |= ft_is_wall(map, y + 0, x + 1) << 0;
	diag_mask = 0;
	diag_mask |= ft_is_wall(map, y - 1, x - 1) << 3;
	diag_mask |= ft_is_wall(map, y - 1, x + 1) << 2;
	diag_mask |= ft_is_wall(map, y + 1, x - 1) << 1;
	diag_mask |= ft_is_wall(map, y + 1, x + 1) << 0;
	return (give_wall(wasd_mask, diag_mask));
}
=== end of ./2_boot/detail_map.c ===
=== start of ./2_boot/map_boot.c ===

#include "bonus_boot_lib.h"
#include <fcntl.h>
#include <unistd.h>

static int	row_count(char *file)
{
	int		fd;
	int		rows;
	char	buffer;

	fd = open(file, O_RDONLY);
	if (fd < 0)
		return (-1);
	rows = 1;
	while (read(fd, &buffer, 1) > 0)
	{
		if (buffer == '\n')
			rows++;
	}
	close(fd);
	return (rows);
}

static char	**copy_map(int fd, char **map, int size)
{
	int		i;
	char	*temp;

	temp = get_next_line(fd);
	i = 0;
	while (i < size && temp)
	{
		map[i] = ft_strtrim(temp, "\n");
		if (!map[i])
		{
			close(fd);
			return (ft_clean_arr(map));
		}
		free(temp);
		temp = get_next_line(fd);
		i++;
	}
	close(fd);
	return (map);
}

static char **load_map(char *file)
{
	int		fd;
	int		size;
	char	**map;

	size = row_count(file);
	if (size < 0)
		return (NULL);
	map = ft_calloc(size, sizeof(char *));
	fd = open(file, O_RDONLY);
	if (fd < 0)
		return (ft_clean_arr(map));
	return (copy_map(fd, map, size));
}

static void	get_p_yx(t_game *game)
{
	int		i;
	char	*chr;
	char	**map;

	map = game->map->layout;
	i = 1;
	while (map[i])
	{
		chr = ft_strchr(map[i], 'P');
		if (chr)
		{
			game->p_y = i;
			game->p_x = chr - map[i];
			return ;
		}
		i++;
	}
}

void	ft_boot_map(t_game *game)
{
	int	i;

	game->map->layout = load_map(game->assets->map_file);
	if (!game->map->layout)
		game->error_bitmask |= MALLOCS_ER;
	game->map->x = ft_strlen(game->map->layout[0]);
	i = 0;
	while (game->map->layout[i])
		i++;
	game->map->y = i;
	ft_detail_map(game->map);
	if (!game->map->arr)
		game->error_bitmask |= MALLOCS_ER;
	get_p_yx(game);
}
=== end of ./2_boot/map_boot.c ===
=== start of ./2_boot/player_boot.c ===

#include "bonus_boot_lib.h"

void	ft_boot_player(t_game *game)
{
	t_player	*p;

	p = game->player;
	p->x = game->p_x * TILE_SIZE;
	p->y = game->p_y * TILE_SIZE;
	p->tile_x = game->p_x;
	p->tile_y = game->p_y;
	p->state = 0;
	p->curr = 0;
	p->dir = 2;
}
=== end of ./2_boot/player_boot.c ===
=== start of ./2_boot/reboot_map.c ===

#include "bonus_boot_lib.h"
#include <stdlib.h>

static void	clone_arr(t_map *map)
{
	int	i;
	int	**new_arr;

	new_arr = ft_calloc(map->y, sizeof(int *));
	if (!new_arr)
		return ;
	i = 0;
	while (i < map->y)
	{
		new_arr[i] = ft_calloc(map->x, sizeof(int));
		if (!new_arr[i])
		{
			ft_clean_int_arr(new_arr, i);
			return ;
		}
		i++;
	}
	map->arr = new_arr;
}

static int	translate_symbol(char c)
{
	int	i;

	i = 0;
	while (MAP_ASSETS[i])
	{
		if (MAP_ASSETS[i] == c)
			return (i);
		i++;
	}
	return (ASSET_ERROR);
}

void	ft_detail_map(t_map *map)
{
	int		x;
	int		y;
	char	c;

	clone_arr(map);
	if (!map->arr)
		return ;
	y = 0;
	while (y < map->y)
	{
		x = 0;
		while (x < map->x)
		{
			if (ft_is_wall(*map, y, x))
				c = ft_prep_wall(*map, y, x);
			else
				c = 'z';
			map->arr[y][x] = translate_symbol(c);
			x++;
		}
		y++;
	}
}
=== end of ./2_boot/reboot_map.c ===
=== start of ./2_boot/swiper.c ===

#include "bonus_boot_lib.h"
#include <stdlib.h>

void	ft_clean_int_arr(int **arr, int i)
{
	int	j;

	j = 0;
	while (j < i)
	{
		free(arr[j]);
		j++;
	}
	free(arr);
}

char	**ft_clean_arr(char **arr)
{
	int	i;

	if (!arr || !*arr)
		return (NULL);
	i = 0;
	while (arr[i])
	{
		free(arr[i]);
		i++;
	}
	free(arr);
	return (NULL);
}

static void	deload_assets(t_assets *assets, void *mlx)
{
	int	i;

	if (!assets || !mlx)
		return ;
	i = -1;
	while (MAP_ASSETS[++i])
		mlx_destroy_image(mlx, assets->a_map[i].img);
	i = -1;
	while (i++ < 96)
		mlx_destroy_image(mlx, assets->a_pla[i].img);
}

void	ft_clean_game(t_game *game)
{
	if (game->map)
	{
		if (game->map->arr)
			ft_clean_int_arr(game->map->arr, game->map->y);
		if (game->map->layout)
			ft_clean_arr(game->map->layout);
		free(game->map);
	}
	if (game->assets)
	{
		deload_assets(game->assets, game->mlx);
		free(game->assets);
	}
	if (game->win)
		mlx_destroy_window(game->mlx, game->win);
	if (game->mlx)
	{
		mlx_destroy_display(game->mlx);
		free(game->mlx);
	}
}
=== end of ./2_boot/swiper.c ===
=== start of ./3_assets/load_player.c ===

#include "bonus_asset_lib.h"

static int	load_a(t_img *dst, void *mlx, char s, char d, int f)
{
	char		path[64];
	const char	*relative;

	ft_bzero(path, sizeof(path));
	relative = "./assets/anim/%c%c%d.xpm";
	ft_sprintf(path, sizeof(path), relative, s, d, f);
	dst->img = mlx_xpm_file_to_image(mlx, path, &dst->w, &dst->h);
	if (!dst->img)
		return (0);
	dst->data = (unsigned int *)mlx_get_data_addr(
		dst->img, &dst->bpp, &dst->line, &dst->endian);
	return (1);
}

int	ft_boot_a_player(t_assets *a, void *mlx)
{
	int			f;
	int			d;
	static int	s;
	static int	i;

	while (s < 3)
	{
		d = 0;
		while (d < 4)
		{
			f = 0;
			while (f < (F_COUNT[s] - '0' + 1))
			{
				if (!load_a(&a->a_pla[i], mlx, S_NAMES[s], D_NAMES[d], f))
					return (0);
				i++;
				f++;
			}
			d++;
		}
		s++;
	}
	return (1);
}
=== end of ./3_assets/load_player.c ===
=== start of ./3_assets/load_map.c ===

#include "so_long_bonus.h"

int ft_boot_a_map(t_assets *a, void *mlx)
{
	int			i;
	t_img		*t;
	static char	path[64];

	i = 0;
	while (MAP_ASSETS[i])
	{
		t = &a->a_map[i];
		ft_sprintf(path, sizeof(path), "./assets/map/%c.xpm", MAP_ASSETS[i]);
		t->img = mlx_xpm_file_to_image(mlx, path, &t->w, &t->h);
		if (!t->img)
			return (0);
		t->data = (unsigned int *)mlx_get_data_addr(t->img,
			&t->bpp, &t->line, &t->endian);
		i++;
	}
	return (1);
}
=== end of ./3_assets/load_map.c ===
=== start of ./3_assets/boot_assets.c ===

# include "bonus_asset_lib.h"

void	ft_boot_assets(t_game *game)
{
	if (!ft_boot_a_player(game->assets, game->mlx) ||
	 !ft_boot_a_map(game->assets, game->mlx))
		game->error_bitmask |= MLXLOAD_ER;
}
=== end of ./3_assets/boot_assets.c ===
=== start of ./4_draw/background.c ===

#include "bonus_draw_lib.h"

static void	blit_bg(t_img *dst, t_img *src, int x_off, int y_off)
{
	int				x;
	int				y;
	unsigned int	*src_pixel;
	unsigned int	*dst_pixel;

	y = 0;
	while (y < src->h)
	{
		x = 0;
		while (x < src->w)
		{
			src_pixel = src->data + (y * src->ppl + x);
			dst_pixel = dst->data + ((y + y_off) * dst->ppl + (x + x_off));
			*dst_pixel = *src_pixel;
			x++;
		}
		y++;
	}
}

void	ft_prepare_frame(t_game *game)
{
	int	w;
	int	h;

	h = 0;
	w = 0;
	while (game->map->layout[h])
		h++;
	while (game->map->layout[0][w])
		w++;
	h *= TILE_SIZE;
	w *= TILE_SIZE;
	game->frame = ft_calloc(sizeof(t_img), 1);
	game->frame->img = mlx_new_image(game->mlx, w, h);
	if (!game->frame->img)
	{
		game->error_bitmask |= MLXLOAD_ER;
		return ;
	}
	game->frame->data = (unsigned int *)mlx_get_data_addr(game->frame->img, 
		&game->frame->bpp, &game->frame->line, &game->frame->endian);
	game->frame->h = h;
	game->frame->w = w;
	game->frame->ppl = game->frame->line / 4;
}

void	ft_draw_bg(t_game *game)
{
	int		y;
	int		x;
	int		i;
	t_img	*t;

	y = 0;
	while (game->map->layout[y])
	{
		x = 0;
		while (game->map->layout[y][x])
		{
			i = game->map->arr[y][x];
			t = &game->assets->a_map[i];
			blit_bg(game->frame, t, x * TILE_SIZE, y * TILE_SIZE);
			x++;
		}
		y++;
	}
}
=== end of ./4_draw/background.c ===
=== start of ./4_draw/looper.c ===

#include "bonus_draw_lib.h"
#include <stdio.h>
#include <sys/time.h>

static long	get_time_us(void)
{
	struct timeval v;
	
	gettimeofday(&v, NULL);
	return ((v.tv_sec * 1000000) + v.tv_usec);
}


int	ft_draw_loop(void *g)
{
	long		time;
	t_game		*game;
	static int	frames[3] = {83333, 62500, 50000};
	static long	last_time;

	
	game = (t_game *)g;
	time = get_time_us();
	if (time - last_time < frames[game->player->state])
		return (0);
	ft_draw_bg(game);
	ft_player_draw(game);
	mlx_put_image_to_window(game->mlx, game->win, game->frame->img, 0, 0);
	last_time = time;
	return (0);
}
=== end of ./4_draw/looper.c ===
=== start of ./4_draw/foreground.c ===

#include "bonus_draw_lib.h"
#include "so_long_bonus.h"

static void	move_player(t_player *p)
{
	if (p->state != 1)
		return ;
	if (p->x < p->tile_x * TILE_SIZE)
		p->x += MOVE_SPEED;
	else if (p->x > p->tile_x * TILE_SIZE)
		p->x -= MOVE_SPEED;
	if (p->y < p->tile_y * TILE_SIZE)
		p->y += MOVE_SPEED;
	else if (p->y > p->tile_y * TILE_SIZE)
		p->y -= MOVE_SPEED;
	if (p->x == p->tile_x * TILE_SIZE &&
	 p->y == p->tile_y * TILE_SIZE)
		p->state = 0;
}

static int	vars_to_i(t_player *p)
{
	int			i;
	static int	offset[] = {0, 24, 56};
	static int	count[] = {6, 8, 10};

	i = offset[p->state];
	i += count[p->state] * p->dir;
	i += p->curr;
	p->curr += 1;
	if (p->curr == count[p->state])
		p->curr = 0;
	return (i);
}

static void	blit_player(t_img *dst, t_img *src, int x_off, int y_off)
{
	int				x;
	int				y;
	unsigned int	*src_pixel;
	unsigned int	*dst_pixel;

	y = 0;
	while (y < src->h)
	{
		x = 0;
		while (x < src->w)
		{
			src_pixel = src->data + (y * src->ppl + x);
			dst_pixel = dst->data + ((y + y_off) * dst->ppl + (x + x_off));
			if (*src_pixel != 0xFF000000)
				*dst_pixel = *src_pixel;
			x++;
		}
		y++;
	}
}

void	ft_player_draw(t_game *game)
{
	int		i;
	t_img	*sprite;

	i = vars_to_i(game->player);
	sprite = &game->assets->a_pla[i];
	if (game->player->state == 1)
		move_player(game->player);
	blit_player(game->frame, sprite, game->player->x, game->player->y);
}
=== end of ./4_draw/foreground.c ===
=== start of ./5_game/so_long_bonus.c ===

#include "so_long_bonus.h"

void	run_game(t_game *game)
{
	int	width;
	int	height;

	game->mlx = mlx_init();
	if (!game->mlx)
		ft_handle_exit(game);
	ft_boot_assets(game);
	ft_prepare_frame(game);
	width = game->map->x * TILE_SIZE;
	height = game->map->y * TILE_SIZE;
	game->win = mlx_new_window(game->mlx, width, height, GAME_NAME);
	mlx_hook(game->win, 17, 0, ft_handle_exit, game);
	mlx_key_hook(game->win, ft_key_handler, game);
	mlx_loop_hook(game->mlx, ft_draw_loop, game);
	mlx_loop(game->mlx);
}

int	main(int ac, char **av)
{
	int		invalid_run;
	t_game	game;

	if (ac != 2)
		return (ft_perror(1, "%s", "Use: ./so_long_bonus MAP_FILE.ber\n"));
	invalid_run = ft_valid_map(av[1]);
	if (invalid_run)
		return (ft_perror(invalid_run, "%s", "Pasing problem\n"));
	ft_boot_game(&game, av[1]);
	if (game.error_bitmask)
		return (ft_perror(game.error_bitmask, "%s", "Boot problem\n"));
	run_game(&game);
}
=== end of ./5_game/so_long_bonus.c ===
=== start of ./5_game/control.c ===

#include "so_long_bonus.h"

static int legal_move(t_game *game, int dir)
{
	int	x;
	int	y;

	x = game->player->tile_x;
	y = game->player->tile_y;
	if (dir == UP)
		y--;
	else if (dir == LEFT)
		x--;
	else if (dir == DOWN)
		y++;
	else if (dir == RIGHT)
		x++;
	game->player->dir = dir;
	return (game->map->arr[y][x] == 0);
}

void	ft_control_player(int key, t_game *game)
{
	int			temp_x;
	int			temp_y;
	t_player	*p;

	p = game->player;
	temp_x = p->tile_x;
	temp_y = p->tile_y;
	if (p->state == 1)
		return ;
	if ((key == KEY_W || key == KEY_UP) && legal_move(game, UP))
		p->tile_y -= 1;
	else if ((key == KEY_S || key == KEY_DOWN) && legal_move(game, DOWN))
		p->tile_y += 1;
	else if ((key == KEY_A || key == KEY_LEFT) && legal_move(game, LEFT))
		p->tile_x -= 1;
	else if ((key == KEY_D || key == KEY_RIGHT) && legal_move(game, RIGHT))
		p->tile_x += 1;
	if (temp_y != p->tile_y || temp_x != p->tile_x)
	{	
		p->state = 1;
		p->curr = 0;
	}
}

int	ft_key_handler(int key, void *g)
{
	t_game	*game;

	game = (t_game *)g;
	if (key == KEY_W || key == KEY_UP || key == KEY_A || key == KEY_LEFT ||
	 key == KEY_S || key == KEY_DOWN || key == KEY_D || key == KEY_RIGHT)
		ft_control_player(key, game);
	else if (key == KEY_ESC)
			ft_handle_exit(game);
	return (0);
}


=== end of ./5_game/control.c ===
=== start of ./6_exit/manager.c ===

#include "so_long_bonus.h"

int	ft_handle_exit(t_game *game)
{
	(void)game;
	exit(0);
	return (0);
}
=== end of ./6_exit/manager.c ===
=== start of ./0_parser/file.c ===

#include "bonus_parse_lib.h"
#include <fcntl.h>
#include <unistd.h>

static char	**bad_array(char **arr, int fd)
{
	int	i;

	if (fd >= 0)
		close(fd);
	i = 0;
	if (arr)
	{
		while (arr[i])
		{
			free(arr[i]);
			i++;
		}
		free(arr);
	}
	return (NULL);
}

static int	map_row_size(char *file)
{
	int		fd;
	int		rows;
	char	buf;

	fd = open(file, O_RDONLY);
	if (fd < 0)
		return (-1);
	rows = 1;
	while (read(fd, &buf, 1) > 0)
	{
		if (buf == '\n')
			rows++;
	}
	close(fd);
	return (rows);
}

static char	**return_map(int fd, char **map, int size)
{
	int		i;
	char	*temp;

	temp = get_next_line(fd);
	i = 0;
	while (i < size && temp)
	{
		map[i] = ft_strtrim(temp, "\n");
		if (!map[i])
			return (bad_array(map, fd));
		if (temp)
			free(temp);
		temp = get_next_line(fd);
		i++;
	}
	close(fd);
	return (map);
}

static char	**load_map(char *file)
{
	int		fd;
	int		n;
	char	**map;

	n = map_row_size(file);
	if (n <= 0)
		return (NULL);
	map = ft_calloc(n, sizeof(char *));
	if (!map)
		return (NULL);
	fd = open(file, O_RDONLY);
	if (fd < 0)
		return (bad_array(map, fd));
	return (return_map(fd, map, n));
}

void	ft_file_check(t_validators *v)
{
	int	i;

	i = ft_strlen(v->map_file);
	if (i < 4)
		v->error_mask |= BERFILE_ER;
	else
	{
		if (ft_strncmp(v->map_file + (i - 4), ".ber", 4))
			v->error_mask |= BERFILE_ER;
	}
	if (!v->error_mask)
		v->arr = load_map(v->map_file);
	if (!v->arr)
		v->error_mask |= MAPFILE_ER;
}
=== end of ./0_parser/file.c ===
=== start of ./0_parser/flood.c ===

#include "bonus_parse_lib.h"
#include <stdlib.h>

static void	coin_flood(int y, int x, t_validators *v)
{
	if (x < 0 || y < 0 || x >= v->x || y >= v->y || v->coin_map[y][x] == '1' ||
	v->coin_map[y][x] == 'F' || v->coin_map[y][x] == 'E')
		return ;
	if (v->coin_map[y][x] == 'C')
		v->coins -= 1;
	v->coin_map[y][x] = 'F';
	coin_flood(y - 1, x, v);
	coin_flood(y, x - 1, v);
	coin_flood(y + 1, x, v);
	coin_flood(y, x + 1, v);
}

static int	exit_flood(int y, int x, t_validators *v)
{

	if (x < 0 || y < 0 || x >= v->x || y >= v->y
		|| v->exit_map[y][x] == '1' || v->exit_map[y][x] == 'F')
		return (0);
	if (v->exit_map[y][x] == 'E')
		return (1);
	v->exit_map[y][x] = 'F';
	return (exit_flood(y - 1, x, v) ||
	exit_flood(y, x + 1, v) ||
	exit_flood(y + 1, x, v) ||
	exit_flood(y, x - 1, v));
}

static char	**clean_arr(t_validators *v)
{
	int	i;

	if (v->coin_map)
	{
		i = -1;
		while (v->coin_map[++i])
			free(v->coin_map[i]);
		free(v->coin_map);
		v->coin_map = NULL;
	}
	if (v->exit_map)
	{
		i = -1;
		while (v->exit_map[++i])
			free(v->exit_map[i]);
		free(v->exit_map);
		v->exit_map = NULL;
	}
	v->error_mask |= MALLOCS_ER;
	return (NULL);
}

static char	**clone_arr(t_validators *v)
{
	int		i;
	char	**new_arr;

	new_arr = ft_calloc(v->y + 1, sizeof(char *));
	if (!new_arr)
		return (clean_arr(v));
	i = 0;
	while (v->arr[i])
	{
		new_arr[i] = ft_strdup(v->arr[i]);
		if (!new_arr[i])
			return (clean_arr(v));
		i++;
	}
	return (new_arr);
}

void	ft_flood_map(t_validators *v)
{
	v->coin_map = clone_arr(v);
	v->exit_map = clone_arr(v);
	if (!v->coin_map || !v->exit_map)
	{
		clean_arr(v);
		return ;
	}
	if (v->coin_map)
		coin_flood(v->p_y, v->p_x, v);
	if (v->exit_map)
		v->exit = exit_flood(v->p_y, v->p_x, v);
	if (v->coins)
		v->error_mask |= LOCKOIN_ER;
	if (!v->exit)
		v->error_mask |= LOCKEXI_ER;
}
=== end of ./0_parser/flood.c ===
=== start of ./0_parser/maparse.c ===

#include "bonus_parse_lib.h"
#include <stddef.h>
#include <stdlib.h>

static void	free2d(char **arr)
{
	int	i;

	i = 0;
	while (arr[i])
	{
		free(arr[i]);
		i++;
	}
	free(arr);
}

static int	deboot_validators(t_validators *v)
{
	if (v->arr)
		free2d(v->arr);
	if (v->coin_map)
		free2d(v->coin_map);
	if (v->exit_map)
		free2d(v->exit_map);
	return (v->error_mask);
}

static t_validators	*boot_validators(char *file, t_validators *v)
{
	v->error_mask = 0;
	v->coins = 0;
	v->exit = 0;
	v->player = 0;
	v->x = 0;
	v->y = 0;
	v->flood = 0;
	v->arr = NULL;
	v->coin_map = NULL;
	v->exit_map = NULL;
	v->map_file = file;
	return (v);
}

int	ft_valid_map(char *map_file)
{
	t_validators	v;

	boot_validators(map_file, &v);
	ft_file_check(&v);
	if (v.error_mask)
		return (v.error_mask);
	ft_uniques(&v);
	if (v.error_mask)
		return (deboot_validators(&v));
	ft_check_ones(&v);
	ft_flood_map(&v);
	deboot_validators(&v);
	return (v.error_mask);
}

=== end of ./0_parser/maparse.c ===
=== start of ./0_parser/ones.c ===

#include "bonus_parse_lib.h"

static int	top_and_bottom(t_validators *v)
{
	int	i;
	int	y;

	i = 0;
	y = v->y - 1;
	while (v->arr[0][i])
	{
		if (v->arr[0][i] != '1')
			return (0);
		i++;
	}
	i = 0;
	while (v->arr[y][i])
	{
		if (v->arr[y][i] != '1')
			return (0);
		i++;
	}
	return (1);
}

static int	sides(t_validators *v)
{
	int	i;
	int	y_lim;
	int	x_lim;

	y_lim = v->y - 1;
	x_lim = v->x - 1;
	i = 1;
	while (i < y_lim)
	{
		if (v->arr[i][0] != '1' || v->arr[i][x_lim] != '1')
			return (0);
		i++;
	}
	return (1);
}

void	ft_check_ones(t_validators *v)
{
	if (!top_and_bottom(v) || !sides(v))
		v->error_mask |= OPENWAL_ER;
}
=== end of ./0_parser/ones.c ===
=== start of ./0_parser/uniques.c ===

#include "bonus_parse_lib.h"

static void	valid_e(t_validators *v)
{
	int	x;
	int	y;

	y = 0;
	while (v->arr[y])
	{
		x = 0;
		while (v->arr[y][x])
		{
			if (v->arr[y][x] == 'E' && !v->exit)
				v->exit = 1;
			else if (v->arr[y][x] == 'E')
				v->error_mask |= EXITPLU_ER;
			x++;
		}
		y++;
	}
	if (!v->exit)
		v->error_mask |= NOEXITS_ER;
}

static void	valid_p(t_validators *v)
{
	int	x;
	int	y;

	y = 0;
	while (v->arr[y])
	{
		x = 0;
		while (v->arr[y][x])
		{
			if (v->arr[y][x] == 'P' && !v->player)
			{
				v->player = 1;
				v->p_x = x;
				v->p_y = y;
			}
			else if (v->arr[y][x] == 'P')
				v->error_mask |= PLAYERS_ER;
			x++;
		}
		y++;
	}
	if (!v->player)
		v->error_mask |= NOPLAYE_ER;
}

static void	valid_c(t_validators *v)
{
	int	y;
	int	x;

	y = 0;
	while (v->arr[y])
	{
		x = 0;
		while (v->arr[y][x])
		{
			if (v->arr[y][x] == 'C')
				v->coins++;
			x++;
		}
		y++;
	}
	// TODO: make coins optional if enemies in place
	if (!v->coins)
		v->error_mask |= NOCOINS_ER;
}

static int	valid_x(t_validators *v)
{
	int		i;

	i = 0;
	v->x = ft_strlen(v->arr[0]);
	while (v->arr[i])
	{
		if ((int)ft_strlen(v->arr[i]) != v->x)
		{
			v->error_mask |= X_VALUE_ER;
			return (0);
		}
		i++;
	}
	v->y = i;
	return (1);
}

void	ft_uniques(t_validators *v)
{
	if (!valid_x(v))
		return ;
	valid_p(v);
	valid_e(v);
	valid_c(v);
}
=== end of ./0_parser/uniques.c ===
