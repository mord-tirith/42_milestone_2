=== start of draw_map.c ===
#include "so_long.h"

void	ft_draw_map(t_game *game)
{
	int		x;
	int		y;
	char	tile;
	void	*img;

	y = 0;
	while (y < game->map.y)
	{
		x = 0;
		while (x < game->map.x)
		{
			tile = game->map.arr[y][x];
			img = game->assets.a_map[(int)tile];
			if (img)
				mlx_put_image_to_window(game->mlx, game->win, img,
				x * TILE_SIZE, y * TILE_SIZE);
			x++;
		}
		y++;
	}
}

=== end of draw_map.c ===
=== start of input_control.c ===

#include "so_long.h"

static void	move_player(t_game *game, int x, int y)
{
	char	target;

	target = game->map.layout[game->p_y + y][game->p_x + x];
	if (target == '1')
		return ;
	if (target == 'E')
	{
		if (game->coins == 0)
			return ; // <- TODO game won function here
		return ;
	}
	if (target == 'C')
	{
		game->coins -= 1;
		game->map.layout[game->p_y + y][game->p_x + x] = '0';
	}
	game->p_x += x;
	game->p_y += y;
	game->move_count += 1;
}

int	ft_keys_hook(int key, t_game *game)
{
	if (key == KEY_ESC)
		ft_exit_game(game);
	else if (key == KEY_W || key == KEY_UP)
		move_player(game, 0, -1);
	else if (key == KEY_A || key == KEY_LEFT)
		move_player(game, -1, 0);
	else if (key == KEY_S || key == KEY_DOWN)
		move_player(game, 0, 1);
	else if (key == KEY_D || key == KEY_RIGHT)
		move_player(game, 1, 0);
	return (0);
}


=== end of input_control.c ===
=== start of so_long.c ===

#include "game_lib.h"

int	main(int ac, char **av)
{
	t_game	*game;

	if (ac != 2)
		return (1);
	game = ft_calloc(1, sizeof(t_game));
	if (!game)
		ft_resolve_error(MALLOCS_ER);
	game->assets.map_file = av[1];
	ft_valid_map(game);
	if (game->error_bitmask)
		ft_resolve_error(game->error_bitmask);
	ft_boot_map(game);
	ft_boot_mlx(game);
	ft_boot_assets(game);
	if (game->error_bitmask)
		ft_resolve_error(game->error_bitmask);
	ft_draw_map(game);
	mlx_key_hook(game->win, ft_keys_hook, &game);
	mlx_hook(game->win, 17, 0, (void *)ft_exit_game, game);
	mlx_loop(game->mlx);
}
=== end of so_long.c ===
