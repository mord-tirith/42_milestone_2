=== start of draw_map.c ===
#include "map_lib.h"
#include "so_long.h"

static void	load_assets(t_game *data)
{
	int		i;
	int		w;
	int		h;
	char	*path;

	i = 0;
	path = ft_strdup("./assets/map/ .xpm");
	if (!path)
		return ;
	while (MAP_ASSETS[i])
	{
		path[13] = MAP_ASSETS[i];
		data->assets.a_map[(int)MAP_ASSETS[i]] = mlx_xpm_file_to_image(
			data->mlx, path, &w, &h);
		i++;
	}
	free(path);
}

void	ft_draw_map(t_game *game)
{
	int		x;
	int		y;
	char	tile;
	void	*img;

	y = 0;
	while (y < game->map.y)
	{
		x = 0;
		while (x < game->map.x)
		{
			tile = game->map.arr[y][x];
			img = game->assets.a_map[(int)tile];
			if (img)
				mlx_put_image_to_window(game->mlx, game->win, img,
				x * TILE_SIZE, y * TILE_SIZE);
		}
		y++;
	}
}

#include <stdlib.h>

int	main(void)
{
	t_game data;

	data.mlx = mlx_init();
	data.map.layout = (char *[]) {
		"1111111111111111111111111111111111111111111111111",
		"1000000000000000000000000000000000000000000000001",
		"1000000000000000000000000000000000000000000000001",
		"1000000000000000000000000000000000000000000000001",
		"1000000000000000000000000000000000000000000000001",
		"1000000000000000000000000000000000000000000000001",
		"1000000000000000000000000000000000000000000000001",
		"1000000000000000000000000000000000000000000000001",
		"1000000000000000000000000000000000000000000000001",
		"1000000000000000000000000000000000000000000000001",
		"1000000000000000000000000000000000000000000000001",
		"1000000000000000000000000000000000000000000000001",
		"1000000000000000000000000000000000000000000000001",
		"1000000000000000000000000000000000000000000000001",
		"1000000000000000000000000000000000000000000000001",
		"1000000000000000000000000000000000000000000000001",
		"1000000000000000000000000000000000000000000000001",
		"1000000000000000000000000000000000000000000000001",
		"1000000000000000000000000000000000000000000000001",
		"1000000000000000000000000000000000000000000000001",
		"1000000000000000000000000000000000000000000000001",
		"1000000000000000000000000000000000000000000000001",
		"1000000000000000000000000000000000000000000000001",
		"1000000000000000000000000000000000000000000000001",
		"1000000000000000000000000000000000000000000000001",
		"1000000000000000000000000000000000000000000000001",
		"1111111111111111111111111111111111111111111111111",
		NULL
	};

	int x = 0;
	int y = 0;
	while (data.map.layout[y])
		y++;
	while (data.map.layout[0][x])
		x++;

	data.map.x = x;
	data.map.y = y;

	data.win = mlx_new_window(data.mlx, x * 32, y * 32, "Map Sandbox");

	ft_detail_map(&data.map);
	load_assets(&data);
	ft_draw_map(&data);

	mlx_loop(data.mlx);
	return (0);
}
=== end of draw_map.c ===
=== start of map_lib.h ===

#ifndef MAP_LIB_H
# define MAP_LIB_H

/* Includes: */
# include "so_long.h"

/* Types: */
typedef struct s_map_arr
{
	int		x;
	int		y;
	char	**arr;
}	t_map_arr;


/* Macros: */
# define WASD_BITMASK "0123456789abcdef"
# define BITMASK_3 "0101010101010101"
# define BITMASK_6 "0011001100110011"
# define BITMASK_7 "3102310231023102"
# define BITMASK_9 "0000111100001111"
# define BITMASK_B "3131020231310202"
# define BITMASK_C "0000000011111111"
# define BITMASK_D "3333111100002222"
# define BITMASK_E "3311331100220022"
# define BITMASK_F "abcdefghijklmnop"

# define MAP_ASSETS "!%@$aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPQRSTUvVwWxXyYzZ#"

/* Functions: */


// Internal Map Utils:
int		ft_is_wall(t_map map, int y, int x);
char	ft_prep_wall(t_map map, int y, int x);
void	ft_detail_map(t_map *map);

#endif
=== end of map_lib.h ===
=== start of reboot_map.c ===

#include "map_lib.h"
#include <stdlib.h>

static void	clean_return(t_map *map)
{
	int	i;

	i = 0;
	while (map->arr[i])
	{
		free(map->arr[i]);
		i++;
	}
	free(map->arr);
}

static void	start_arr(t_map *map)
{
	int		i;
	char	**new_arr;

	new_arr = malloc(sizeof(char *) * (map->y + 1));
	if (!new_arr)
		return ;
	i = 0;
	while (i < map->y)
	{
		new_arr[i] = malloc(sizeof(char) * (map->x + 1));
		if (!new_arr[i])
			return (clean_return(map));
		new_arr[i][map->x] = '\0';
		i++;
	}
	new_arr[i] = NULL;
	map->arr = new_arr;
}

static char	prep_floor(t_map *map, int y, int x)
{
	static int	last_rand;
	int			faux_random;
	char		*floors;

	floors = "wxyz";

	if (x - 1 >= 0)
		faux_random += map->layout[y][x - 1];
	if (y - 1 >= 0)
		faux_random += map->layout[y - 1][x];
	if (x + 1 < map->x)
		faux_random += map->layout[y][x + 1];
	if (y + 1 < map->y)
		faux_random += map->layout[y + 1][x];
	faux_random %= 4;
	if (faux_random == last_rand)
		faux_random = (faux_random + 1) % 4;
	last_rand = faux_random;
	return (floors[faux_random]);
}

void	ft_detail_map(t_map *map)
{
	int	x;
	int	y;

	start_arr(map);
	if (!map->arr)
		return ;
	y = 0;
	while (map->layout[y])
	{
		x = 0;
		while (map->layout[y][x])
		{
			if (ft_is_wall(*map, y, x))
				map->arr[y][x] = ft_prep_wall(*map, y, x);
			else
				map->arr[y][x] = prep_floor(map, y, x); 
			x++;
		}
		y++;
	}
}
=== end of reboot_map.c ===
=== start of so_long.h ===

#ifndef SO_LONG_H
# define SO_LONG_H

/* Global Includes: */
# include "../../.libft/inc/libftpp.h"
# include "../../minilibx-linux/mlx.h"

/* Types: */

typedef struct s_map
{
	int		x;
	int		y;
	char	**arr;
	char	**layout;
}	t_map;

typedef struct s_data
{
	void	*a_map[128];
}	t_assets;

typedef struct s_game
{
	int			error_bitmask;
	void		*mlx;
	void		*win;
	t_map		map;
	t_assets	assets;
}	t_game;

/* Macros: */
# define TILE_SIZE 32

/* Functions: */
int	ft_valid_map(t_game *game);
#endif
=== end of so_long.h ===
=== start of translate_walls.c ===

# include "map_lib.h"

int	ft_is_wall(t_map map, int y, int x)
{
	char	c;
	int		s_x;
	int		s_y;

	s_x = map.x;
	s_y = map.y;
	if (x < 0 || x >= s_x || y < 0 || y >= s_y)
		return (1);
	c = map.layout[y][x];
	return (c == '1');
}

static char	final_walls(int mask_dir, int mask_dig)
{
	if (mask_dir == 10)
		return ('Q');
	if (mask_dir == 11)
		return ("RSTU"[BITMASK_B[mask_dig] - '0']);
	if (mask_dir == 12)
		return ("VW"[BITMASK_C[mask_dig] - '0']);
	if (mask_dir == 13)
		return ("XYZ%"[BITMASK_D[mask_dig] - '0']);
	if (mask_dir == 14)
		return ("!@#$"[BITMASK_E[mask_dig] - '0']);
	if (mask_dir == 15)
		return (BITMASK_F[mask_dig]);
	return ('*');
}

static char	give_wall(int mask_dir, int mask_dig)
{
	if (mask_dir == 0)
		return ('A');
	if (mask_dir == 1)
		return ('B');
	if (mask_dir == 2)
		return ('C');
	if (mask_dir == 3)
		return ("DE"[BITMASK_3[mask_dig] - '0']);
	if (mask_dir == 4)
		return ('F');
	if (mask_dir == 5)
		return ('G');
	if (mask_dir == 6)
		return ("HI"[BITMASK_6[mask_dig] - '0']);
	if (mask_dir == 7)
		return ("JKLM"[BITMASK_7[mask_dig] - '0']);
	if (mask_dir == 8)
		return ('N');
	if (mask_dir == 9)
		return ("OP"[BITMASK_9[mask_dig] - '0']);
	return (final_walls(mask_dir, mask_dig));
}

char	ft_prep_wall(t_map map, int y, int x)
{
	int	wasd_mask;
	int	diag_mask;

	wasd_mask = 0;
	wasd_mask |= ft_is_wall(map, y - 1, x + 0) << 3;
	wasd_mask |= ft_is_wall(map, y + 0, x - 1) << 2;
	wasd_mask |= ft_is_wall(map, y + 1, x + 0) << 1;
	wasd_mask |= ft_is_wall(map, y + 0, x + 1) << 0;
	diag_mask = 0;
	diag_mask |= ft_is_wall(map, y - 1, x - 1) << 3;
	diag_mask |= ft_is_wall(map, y - 1, x + 1) << 2;
	diag_mask |= ft_is_wall(map, y + 1, x - 1) << 1;
	diag_mask |= ft_is_wall(map, y + 1, x + 1) << 0;
	return (give_wall(wasd_mask, diag_mask));
}
=== end of translate_walls.c ===
