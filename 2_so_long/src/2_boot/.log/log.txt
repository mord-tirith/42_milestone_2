=== start of assets_boot.c ===

#include "boot_lib.h"
#include "so_long.h"

static void	boot_map(t_assets *a, void *mlx, int *mask)
{
	int			i;
	char		path[20];

	i = 0;
	ft_bzero(path, 20);
	while (MAP_ASSETS[i])
	{
		ft_sprintf(path, 20, "../assets/map/%c.xpm", MAP_ASSETS[i]);
		a->a_map[i] = mlx_xpm_file_to_image(mlx, path, &a->w, &a->h);
		if (!a->a_map[i])
		{
			*mask |= MLXLOAD_ER;
			ft_printf("Failed to load %s\n", path);
			return ;
		}
		i++;
	}
}

void	ft_boot_assets(t_game *game)
{
	boot_map(game->assets, game->mlx, &game->error_bitmask);
	//TODO: load player and sprites assets
}
=== end of assets_boot.c ===
=== start of boot.c ===

#include "boot_lib.h"

static void	boot_t_game(t_game *game)
{
	game->error_bitmask = 0;
	game->move_count = 0;
	game->p_x = 0;
	game->p_y = 0;
	game->coins = 0;
	game->mlx = NULL;
	game->win = NULL;
	game->map = ft_calloc(1, sizeof(t_map));
	game->assets = ft_calloc(1, sizeof(t_assets));
	if (!game->map || !game->assets)
		game->error_bitmask |= MALLOCS_ER;
}

int main(int ac, char **av)
{
	t_game	game;

	if (ac != 2)
		return (0);
	boot_t_game(&game);
	game.assets->map_file = av[1];
	ft_boot_map(&game);
	ft_boot_mlx(&game);
	ft_boot_assets(&game);

	ft_clean_game(&game);
	return (0);
}
=== end of boot.c ===
=== start of boot_lib.h ===

#ifndef BOOT_LIB_H
# define BOOT_LIB_H

# include "so_long.h"

char	**ft_clean_arr(char **arr);
void	ft_clean_game(t_game *game);
void	ft_boot_map(t_game *game);
void	ft_boot_assets(t_game *game);
void	ft_boot_mlx(t_game *game);


#endif
=== end of boot_lib.h ===
=== start of map_boot.c ===

#include "boot_lib.h"
#include "so_long.h"
#include <fcntl.h>
#include <unistd.h>

static int	row_count(char *file)
{
	int		fd;
	int		rows;
	char	buffer;

	fd = open(file, O_RDONLY);
	if (fd < 0)
		return (-1);
	rows = 1;
	while (read(fd, &buffer, 1) > 0)
	{
		if (buffer == '\n')
			rows++;
	}
	close(fd);
	return (rows);
}

static char	**copy_map(int fd, char **map, int size)
{
	int		i;
	char	*temp;

	temp = get_next_line(fd);
	i = 0;
	while (i < size && temp)
	{
		map[i] = ft_strtrim(temp, "\n");
		if (!map[i])
		{
			close(fd);
			return (ft_clean_arr(map));
		}
		free(temp);
		temp = get_next_line(fd);
		i++;
	}
	close(fd);
	return (map);
}

static char **load_map(char *file)
{
	int		fd;
	int		size;
	char	**map;

	size = row_count(file);
	if (size < 0)
		return (NULL);
	map = ft_calloc(size, sizeof(char *));
	fd = open(file, O_RDONLY);
	if (fd < 0)
		return (ft_clean_arr(map));
	return (copy_map(fd, map, size));
}

void	ft_boot_map(t_game *game)
{
	int	i;

	game->map->layout = load_map(game->assets->map_file);
	if (!game->map->layout)
		game->error_bitmask |= MALLOCS_ER;
	game->map->x = ft_strlen(game->map->layout[0]);
	i = 0;
	while (game->map->layout[i])
		i++;
	game->map->y = i;
}
=== end of map_boot.c ===
=== start of mlx_boot.c ===

#include "boot_lib.h"
#include "so_long.h"

void	ft_boot_mlx(t_game *game)
{
	int	width;
	int	height;

	game->mlx = mlx_init();
	if (!game->mlx)
	{
		game->error_bitmask |= MLXLOAD_ER;
		return ;
	}
	width = game->map->x * TILE_SIZE;
	height = game->map->y * TILE_SIZE;
	game->win = mlx_new_window(game->mlx, width, height, GAME_NAME);
	if (!game->win)
		game->error_bitmask |= MLXLOAD_ER;
}
=== end of mlx_boot.c ===
=== start of so_long.h ===

#ifndef SO_LONG_H
# define SO_LONG_H

/* Global Includes: */
# include "../../libft/inc/libftpp.h"
# include "../minilibx-linux/mlx.h"

/* Types: */

typedef struct s_map
{
	int		x;
	int		y;
	char	**arr;
	char	**layout;
}	t_map;

typedef struct s_assets
{
	int		h;
	int		w;
	char	*map_file;
	void	*a_map[52];
}	t_assets;

typedef struct s_game
{
	int			error_bitmask;
	int			move_count;
	int			p_x;
	int			p_y;
	int			coins;
	void		*mlx;
	void		*win;
	t_map		*map;
	t_assets	*assets;
}	t_game;

typedef enum e_flags
{	
	SUCCESSFUL = 0,
	MALLOCS_ER = 1 << 0,
	BERFILE_ER = 1 << 1,
	MAPFILE_ER = 1 << 2,
	X_VALUE_ER = 1 << 3,
	PLAYERS_ER = 1 << 4,
	EXITPLU_ER = 1 << 5,
	OPENWAL_ER = 1 << 6,
	NOCOINS_ER = 1 << 7,
	NOPLAYE_ER = 1 << 8,
	NOEXITS_ER = 1 << 9,
	LOCKOIN_ER = 1 << 10,
	LOCKEXI_ER = 1 << 11,
	WRONGAC_ER = 1 << 12,
	MLXLOAD_ER = 1 << 13
}	t_flags;

/* System Dependant Macros: */
# ifdef __linux__
#  define KEY_ESC	65307
#  define KEY_W		119
#  define KEY_A		97
#  define KEY_S		115
#  define KEY_D		100
#  define KEY_UP	65362
#  define KEY_LEFT	65361
#  define KEY_DOWN	65364
#  define KEY_RIGHT	65363
#  define LIN_FLAG	1

# elif __APPLE__
#  define KEY_ESC	53
#  define KEY_W		13
#  define KEY_A		0
#  define KEY_S		1
#  define KEY_D		2
#  define KEY_UP	126 
#  define KEY_LEFT	123 
#  define KEY_DOWN	125
#  define KEY_RIGHT	124 
#  define LIN_FLAG	0
# endif

/* Macros: */
# define GAME_NAME "so_long"
# define TILE_SIZE 48
# define MAP_ASSETS "!%@$aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPQRSTUvVwWxXyYzZ#"

/* Functions: */
int	ft_valid_map(char *map_file);

// Boot functions:
void	ft_detail_map(t_map *map);

// Exit functions:
void	ft_exit_game(t_game *game);

// Error management:
void	ft_resolve_error(int mask);

// Draw functions:
void	ft_draw_map(t_game *game);
#endif
=== end of so_long.h ===
=== start of swiper.c ===

#include "boot_lib.h"
#include "so_long.h"
#include <stdlib.h>

char	**ft_clean_arr(char **arr)
{
	int	i;

	if (!arr || !*arr)
		return (NULL);
	i = 0;
	while (arr[i])
	{
		free(arr[i]);
		i++;
	}
	free(arr);
	return (NULL);
}

static void	deload_assets(t_assets *assets, void *mlx)
{
	int	i;

	if (!assets || !mlx)
		return ;
	i = -1;
	while (MAP_ASSETS[++i])
		mlx_destroy_image(mlx, assets->a_map[i]);

}

void	ft_clean_game(t_game *game)
{
	if (game->map)
	{
		if (game->map->arr)
			ft_clean_arr(game->map->arr);
		if (game->map->layout)
			ft_clean_arr(game->map->layout);
		free(game->map);
	}
	if (game->assets)
	{
		deload_assets(game->assets, game->mlx);
		free(game->assets);
	}
	if (game->win)
		mlx_destroy_window(game->mlx, game->win);
	if (game->mlx)
	{
		mlx_destroy_display(game->mlx);
	}
}
=== end of swiper.c ===
